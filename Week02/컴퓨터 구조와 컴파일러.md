### 😎 컴퓨터 구조

- **`컴퓨터가 이해하는 정보`**
  - 데이터 → 컴퓨터와 주고받는/내부에 저장된 정보
  - 명령어 → 0과 1로 숫자 또는 문자를 표현
- **`컴퓨터의 핵심 부품`**
  - CPU → 메모리에 저장된 값을 읽어들이고, 해석하고, 실행하는 장치
    - ALU, 레지스터, 제어 장치로 구성
  - 메모리 → 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 함
    - 메모리는 실행되는 프로그램의 명령어와 데이터를 저장
    - 메모리에 저장된 값의 위치는 주소로 알 수 있다.
  - 보조기억장치 → 보관할 정보 저장
    - 전원이 꺼져도 보관될 프로그램을 저장한다.
  - 입출력 장치 → 컴퓨터 외부에 연결되어 내부와 정보를 교환할 수 있는 장치

<aside>
💡<strong>CPU의 구성<strong>

</aside>

> **ALU (Arithmetic Logic Unit)**

    - 산술 논리 연산 장치로, 컴퓨터의 중앙 처리 장치(CPU) 내에서 산술 연산과 논리 연산 등을 수행한다.

> **제어장치 (CU)**

    - 컴퓨터의 전체 작업을 제어하고 조정하는 역할
    - 명령어의 해석, 명령어 실행 흐름의 제어, 다른 하드웨어 구성 요소들 간의 데이터 흐름 조정 등을 담당

> **레지스터 (Register)**

    - 중앙 처리 장치 (CPU) 내에 존재하는 고속 메모리 장치로, 데이터나 명령어를 **일시적으로** 저장하고 처리하는 데 사용한다.
    	- 종류
        	- 프로그램 카운터 (PC) : 메모리에서 가져올 명령어의 주소를 저장
        	- 명령어 레지스터 (IR) : 현재 실행 중인 명령어를 저장
        	- 스택 포인터 (SP) : 함수 호출 시 호출 스택의 위치를 관리
        	- 범용 레지스터 : 연산을 수행하는데 필요한 데이터나 중간 결과를 저장
        	- 베이스 레지스터 : 기준 주소 저장

<aside>
👀 <strong>메모리<strong>

</aside>

- **`물리 주소`**
  - 메모리 입장에서 바라본 주소
  - 말 그대로 정보가 실제로 저장된 하드웨어상의 주소
- **`논리 주소`**
  - CPU와 실행 중인 프로그램 입장에서 바라본 주소
  - 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소
- **`메모리 관리 장치 (MMU)`**
  - 논리 주소와 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환한다.

> **캐시**

**`저장 장치 계층 구조`**

→ CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다. 속도가 빠른 저장장치는 더 비쌈!

![Image](https://github.com/user-attachments/assets/437f020a-591d-4e29-ba8a-ec0d41d1dd79)

**`캐시 메모리`**

→ CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 저장 장치

```jsx
- 매번 실행할 프로그램의 명령어를 메모리에 가서 가져오는 것은 효율성이 좋지 않다. 🙅🏻‍♂️
- 앞으로 실행할 것 같은 데이터, 혹은 자주 참조한 데이터를 미리 가져와서 참조하여 효율성을 높이자!
- **참조 지역성의 원리**
	- 캐시 히트 : 예측이 맞을 경우 (CPU가 캐시 메모리의 값을 참조할 경우)
	- 캐시 미스 : 예측이 틀릴 경우
	- 캐시 적중률 : 캐시 히트 횟수 / 캐시 히트 횟수 + 캐시 미스 횟수
```

**`명령어 구조`**

![Image](https://github.com/user-attachments/assets/f9cd58c0-2165-4a29-b519-e1fe84dd41ba)

### ✨ 운영체제

- 실행할 프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램.
  - **운영체제는 프로그램을 위한 프로그램!**

```jsx
## 💥 운영체제가 제공하는 기능
1. 프로세스 관리
	- 동시다발적으로 생성/실행/삭제되는 다양한 프로세스 관리 : 프로세스와 스레드, 프로세스 동기화, 교착상태 해결
2. 자원 접근 및 할당
  - CPU 스케쥴링 : 어떤 프로세스를 먼저, 얼마나 오래 실행할까?
  - 메모리 : 페이징, 스와핑 (다양한 프로세스 교체 알고리즘이 존재함.)
  - 입출력 장치
3. 파일 시스템 관리
  - 관련된 정보를 파일이라는 단위로 저장 장치에 보관
  - 파일들을 묶어 폴더 (디렉토리) 단위로 보관
```

> **커널**

- 운영체제의 핵심 기능을 담당한다.

![Image](https://github.com/user-attachments/assets/f76e5453-90fa-451c-aca6-d6bb414668ad)

> **프로그램 언어의 구성 요소 (일부)**

**`변수 & 상수`**

| 구분        | 원시형(Primitive)    | 참조형(Reference/Object)                |
| ----------- | -------------------- | --------------------------------------- |
| 저장 방식   | 값 자체 저장         | 주소(참조) 저장                         |
| 메모리 구조 | 스택(stack)          | 힙(heap)                                |
| 복사 방식   | 값 복사(완전한 복사) | 참조 복사(주소만 복사)                  |
| 비교 방식   | 값 비교              | 참조 주소 비교                          |
| 변경 시     | 서로 영향 없음.      | 하나 바꾸면 같이 바뀜(얕은 복사일 경우) |

🌛 원시형 : 값 그 자체를 저장하는 **단순한 타입**

```
let a = 10;
let b = a;
b = 20;

console.log(a); // 10
console.log(b); // 20
```

→ `a`와 `b`는 완전히 **서로 다른 값**을 저장하고 있어서 **영향 없음**

**🌸 원시형 종류**

- `number`
- `string`
- `boolean`
- `null`
- `undefined`
- `symbol`
- `bigint`

🌜 참조형 : 값이 아니라 **값이 있는 주소(참조)를 저장하는 타입**

```
const obj1 = { name: "Yunseo" };
const obj2 = obj1;

obj2.name = "Won";

console.log(obj1.name); // 👉 "Won"
console.log(obj2.name); // 👉 "Won"
```

→ `obj1`과 `obj2`는 같은 객체를 참조(= 같은 주소)하고 있기 때문에, 하나 바꾸면 같이 바뀜!

<aside>
🐾 <strong>리터럴</strong>

> 리터럴(literal)은 **그 자체로 "값"을 의미하는 표현.**
>
> 즉, 코드에서 **직접 써놓은 값 자체**를 말한다!

</aside>

```jsx
const a = 10; // 숫자 리터럴
const b = "Hello"; // 문자열 리터럴
const c = true; // 불리언 리터럴
const d = null; // null 리터럴
const e = [1, 2, 3]; // 배열 리터럴
const f = { name: "윤서" }; // 객체 리터럴
```

### 🌪️ 컴파일러

> **사람이 작성한 코드(고급 언어)를, 컴퓨터가 이해할 수 있는 언어(기계어)로 바꿔주는 프로그램.**

<aside>
🦢 <strong>컴파일러 vs 인터프리터<strong>

</aside>

| 구분      | 컴파일러                    | 인터프리터                         |
| --------- | --------------------------- | ---------------------------------- |
| 실행 방식 | 코드를 한 번에 변환 후 실행 | 한 줄씩 해석하며 실행              |
| 예시 언어 | C, C++, Java (JVM)          | Python, JavaScript                 |
| 속도      | 처음엔 느리지만 실행은 빠름 | 빠르게 시작하지만 전체 성능은 느림 |
| 에러 처리 | 컴파일 시점에 모두 체크     | 실행 중간에 에러 발견 가능         |

<aside>
😄 <strong>TypeScript Compiler<strong>

- .ts 파일을 .js 파일로 변환하고 타입을 검사한다.
- 변수, 함수, 객체의 타입을 확인해서 **오타/실수/버그를 사전에 방지**
- 실행 전에 코드를 미리 "정적 분석"해서 오류를 알려준다.
</aside>

| **도구**    | **설명**                               |
| ----------- | -------------------------------------- |
| **`tsc`**   | 타입 검사 + JS 변환                    |
| **`babel`** | 최신 JS → 구버전 JS 변환 (타입 검사 X) |
