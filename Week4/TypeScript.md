### 🤔 왜 타입스크립트를 배우는가?

- **`안정성 보장`**
  - 정적 타이핑 제공 → 컴파일 단계에서 타입 검사
  - 자바스크립트에서 발생하는 런타입 에러 방지 → 안정성이 높아짐
- **`개발 생산성 향상`**
  - IDE에서 타입 자동 완성을 제공 → 변수/함수 타입 추론
  - 리액트에서 사용할 때 사용부에서 prop을 확인할 수 있음
- **`협업에 유리`**
  - 인터페이스 제네릭 등을 지원
    - **타입스크립트 인터페이스** : 객체 구조를 정의하는 역할로, 특정 객체가 가지는 속성/메소드 집합을 인터페이스로 정의한 것.

### 🗣️ 타입스크립트 컴파일러

- 타입스크립트 코드를 분석하고 자바스크립트로 컴파일하도록 돕는 도구
- 타입 정의 파일 **`(.d.ts)`** 나 소스 맵 파일 **`(*.js.map)`** 도 함께 생성한다.
- 소스 파일에 문제가 있는 경우 진단 정보를 제공한다.

  ![Image](https://github.com/user-attachments/assets/ef120a5f-4fb2-4b00-b317-4419fb672c28)

### 🐵 타입 시스템

- 변수란 값을 저장할 수 있는 공간이자 값을 가리키는 이름
- **메모리 공간은 한정적이므로, 효율적으로 저장하려면 해당 메모리 공간을 차지할 값의 크기를 알아야 한다.**
- 데이터 타입은 **여러 종류의 데이터를 식별하는 분류 체계**로 컴파일러에게 값의 형태를 알려준다.

> **타입 명시**

- 변수에 저장된 값이 어떤 일을 할 수 있는지 미리 알 수 있다.

  ```jsx
  const num: number = 123;
  const str: string = "123";

  function func(n: number) {
  ...
  }

  func(str); // error
  ```

  - **`매개변수 타입으로 지정된 값만 넘길 수 있으므로 에러 발생`**

### 🐱 정적 타입과 동적 타입

- **`자바스크립트의 타입`**
  - 개발자가 타입을 직접 정의할 필요 없다!
  - **타입을 결정하는 시점**에 따라 정적 타입과 동적 타입으로 분류된다.

**🕶️ 정적 타입 시스템**

```jsx
- 모든 변수의 타입이 컴파일 타임에 결정된다.
- 개발자가 타입을 명시해야 한다.
- C, Java, TypeScript 등
- 컴파일 타임에 타입 에러를 발견할 수 있으므로 안정성을 보장한다.
```

**🦦 동적 타입 시스템**

```jsx
- 변수의 타입이 런타임에 결정된다.
- Python, JavScript 등
- 개발자가 타입을 정의해줄 필요가 없다.
- 프로그램 실행시 타입 에러가 발견되므로 프로그램 오류가 언제 생길지 모른다.
```

**🌿 컴파일 타임 vs 런타임**

```jsx
- 컴파일 타임 : 기계가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점
- 런타임 : 변환된 파일이 메모리에 적재되어 실행되는 시점
```

> **강타입 / 약타입**

- 암묵적 타입 변환 여부에 따라 분류한다.
- 암묵적 변환은 개발자의 의도와 다르게 동작할 수 있으므로 오류 발생 확률이 높아진다.

**`강타입 언어`**

- 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 혹은 인터프리터에서 에러를 발생시킨다.
- C++, Java, TypeScript

**`약타입 언어`**

- 서로 다른 타입을 갖는 값끼리 연산할 때 컴파일러 또는 인터프리터가 내부적으로 판단해 특정값의 타입을 변환하여 연산을 수행한다.
- Python, Ruby, JavaScript

### 🌵 Type Annotation

- 변수나 상수, 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 저장될 값의 타입을 컴파일러에게 직접 알려주는 문법

  ```jsx
  // 변수명: type

  let isDone: boolean = false;
  let color: string = "blue";
  let list: number[] = [1, 2, 3];
  let x: [string, number]; // tuple
  ```

> **구조적 타입 시스템**

- 타입을 비교할 때 구조로 타입을 구분한다.
- 타입의 이름이 아니라, 타입의 “구조”가 같으면 같은 타입으로 본다는 의미!

  ```jsx
  type A = { name: string };
  type B = { name: string };

  const a: A = { name: "Alice" };
  const b: B = a; // OK! 구조가 같으니까
  ```

- **`속성과 타입이 같으면 호환`**

  ```jsx
  type User = { id: number, name: string };
  type Member = { name: string, id: number };

  const user: User = { id: 1, name: "홍길동" };
  const member: Member = user; // 순서 달라도 OK
  ```

- **`추가 속성은 괜찮지만 누락은 X`**

  ```jsx
  type Animal = { name: string };
  type Dog = { name: string, breed: string };

  const dog: Dog = { name: "콩이", breed: "푸들" };
  const animal: Animal = dog; // OK

  const badDog: Dog = { name: "콩이" }; // breed 없음
  ```

**😮 이름으로까지 구분하는 명목적 타입 시스템보다는 안정성이 떨어지지만, 자바스크립트를 모델링한 언어인만큼 쉬운 사용성/안정성 사이의 균형을 맞추기 위해 구조적 타입 시스템을 선택한 것!**
